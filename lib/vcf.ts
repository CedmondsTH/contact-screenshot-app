import vCard from 'vcards-js';
import { ContactData, VCFOptions } from '../types/contact';

// Generate VCF file from contact data
export function generateVCF(contact: ContactData, options: VCFOptions = {}): Blob {
  // Create a new vCard
  const card = vCard();
  
  // Set name fields
  if (contact.firstName && contact.lastName) {
    card.firstName = contact.firstName;
    card.lastName = contact.lastName;
  } else if (contact.fullName) {
    const nameParts = contact.fullName.split(' ');
    if (nameParts.length >= 2) {
      card.firstName = nameParts[0];
      card.lastName = nameParts.slice(1).join(' ');
    } else {
      card.firstName = contact.fullName;
    }
  }
  
  // Set formatted name
  card.formattedName = contact.fullName || `${contact.firstName || ''} ${contact.lastName || ''}`.trim();
  
  // Set organization and title
  if (contact.company) {
    card.organization = contact.company;
  }
  
  if (contact.title) {
    card.title = contact.title;
  }
  
  // Set contact information
  if (contact.email) {
    card.email = contact.email;
  }
  
  // Handle phone numbers
  if (contact.phone) {
    card.cellPhone = contact.phone;
  }
  
  if (contact.mobilePhone && contact.mobilePhone !== contact.phone) {
    card.homePhone = contact.mobilePhone;
  }
  
  if (contact.workPhone) {
    card.workPhone = contact.workPhone;
  }
  
  // Set URLs
  if (contact.website) {
    card.url = contact.website;
  }
  
  // Add LinkedIn URL as a social profile
  if (contact.linkedIn) {
    // Add LinkedIn URL to the URL field with a label
    if (!contact.website) {
      card.url = contact.linkedIn;
    }
    // Also add as a note if we have custom fields enabled
    if (options.includeNotes !== false) {
      const existingNote = card.note || '';
      card.note = existingNote ? `${existingNote}\nLinkedIn: ${contact.linkedIn}` : `LinkedIn: ${contact.linkedIn}`;
    }
  }
  
  // Set address if available
  if (contact.address || contact.city || contact.state || contact.zipCode || contact.country) {
    card.homeAddress.label = 'Home Address';
    card.homeAddress.street = contact.address || '';
    card.homeAddress.city = contact.city || '';
    card.homeAddress.stateProvince = contact.state || '';
    card.homeAddress.postalCode = contact.zipCode || '';
    card.homeAddress.countryRegion = contact.country || '';
  }
  
  // Add location information for LinkedIn profiles
  if (contact.location && !contact.address) {
    card.homeAddress.label = 'Location';
    card.homeAddress.city = contact.location;
  }
  
  // Add headline as note for LinkedIn profiles
  if (contact.headline && options.includeNotes !== false) {
    const existingNote = card.note || '';
    const headlineNote = `Headline: ${contact.headline}`;
    card.note = existingNote ? `${existingNote}\n${headlineNote}` : headlineNote;
  }
  
  // Add custom fields if provided
  if (options.customFields) {
    const existingNote = card.note || '';
    const customFieldsNote = Object.entries(options.customFields)
      .map(([key, value]) => `${key}: ${value}`)
      .join('\n');
    card.note = existingNote ? `${existingNote}\n${customFieldsNote}` : customFieldsNote;
  }
  
  // Add metadata note
  if (options.includeNotes !== false) {
    const existingNote = card.note || '';
    const metadata = `Generated by Contact Screenshot App on ${new Date().toLocaleDateString()}`;
    card.note = existingNote ? `${existingNote}\n\n${metadata}` : metadata;
  }
  
  // Generate VCF string
  const vcfString = card.getFormattedString();
  
  // Create and return blob
  return new Blob([vcfString], { type: 'text/vcard;charset=utf-8' });
}

// Download VCF file
export function downloadVCF(contact: ContactData, options: VCFOptions = {}): void {
  const blob = generateVCF(contact, options);
  const url = URL.createObjectURL(blob);
  
  // Create download link
  const link = document.createElement('a');
  link.href = url;
  
  // Generate filename
  const name = contact.fullName || `${contact.firstName || ''} ${contact.lastName || ''}`.trim() || 'contact';
  const sanitizedName = name.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_');
  link.download = `${sanitizedName}_contact.vcf`;
  
  // Trigger download
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  // Clean up
  URL.revokeObjectURL(url);
}

// Generate multiple VCF files as a single file
export function generateBatchVCF(contacts: ContactData[], options: VCFOptions = {}): Blob {
  const vcfStrings = contacts.map(contact => {
    const card = vCard();
    
    // Set basic fields (simplified version)
    if (contact.firstName && contact.lastName) {
      card.firstName = contact.firstName;
      card.lastName = contact.lastName;
    } else if (contact.fullName) {
      const nameParts = contact.fullName.split(' ');
      if (nameParts.length >= 2) {
        card.firstName = nameParts[0];
        card.lastName = nameParts.slice(1).join(' ');
      } else {
        card.firstName = contact.fullName;
      }
    }
    
    card.formattedName = contact.fullName || `${contact.firstName || ''} ${contact.lastName || ''}`.trim();
    
    if (contact.company) card.organization = contact.company;
    if (contact.title) card.title = contact.title;
    if (contact.email) card.email = contact.email;
    if (contact.phone) card.cellPhone = contact.phone;
    if (contact.website) card.url = contact.website;
    
    return card.getFormattedString();
  });
  
  const combinedVCF = vcfStrings.join('\n');
  return new Blob([combinedVCF], { type: 'text/vcard;charset=utf-8' });
}

// Download batch VCF file
export function downloadBatchVCF(contacts: ContactData[], filename: string = 'contacts_batch.vcf', options: VCFOptions = {}): void {
  const blob = generateBatchVCF(contacts, options);
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  URL.revokeObjectURL(url);
}

// Validate VCF data before generation
export function validateVCFData(contact: ContactData): { isValid: boolean; errors: string[] } {
  const errors: string[] = [];
  
  // Check required fields
  if (!contact.fullName && !contact.firstName && !contact.lastName) {
    errors.push('Name is required (fullName or firstName/lastName)');
  }
  
  // Validate email format if provided
  if (contact.email && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(contact.email)) {
    errors.push('Invalid email format');
  }
  
  // Validate phone format if provided
  if (contact.phone && !/^[\d\s\-\(\)\+]+$/.test(contact.phone)) {
    errors.push('Invalid phone number format');
  }
  
  // Validate URLs if provided
  if (contact.website && !isValidUrl(contact.website)) {
    errors.push('Invalid website URL');
  }
  
  if (contact.linkedIn && !isValidUrl(contact.linkedIn)) {
    errors.push('Invalid LinkedIn URL');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
}

// Helper function to validate URLs
function isValidUrl(string: string): boolean {
  try {
    new URL(string);
    return true;
  } catch (_) {
    return false;
  }
}

// Preview VCF content as string
export function previewVCF(contact: ContactData, options: VCFOptions = {}): string {
  const blob = generateVCF(contact, options);
  return new Promise<string>((resolve) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result as string);
    reader.readAsText(blob);
  }) as any; // Type assertion to match sync expectation
} 